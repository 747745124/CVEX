import logging
import re
import sys
import tempfile
import threading
import time

import fabric
import procmon_parser
from invoke import UnexpectedExit

from cvex.consts import *
from cvex.logger import get_logger
from cvex.vm import VM


class Exploit:
    log: logging.Logger
    vms: list
    ports: list[int]

    def __init__(self, vms: list[VM], ports: list[int]):
        self.log = get_logger("exploit")
        self.vms = vms
        self.ports = ports

    def _read_output(self, runner: fabric.runners.Remote):
        try:
            stdouts = 0
            while True:
                if runner.program_finished.is_set():
                    return
                new_stdouts = len(runner.stdout)
                if new_stdouts > stdouts:
                    for i in range(stdouts, new_stdouts):
                        self.log.debug(runner.stdout[i])
                stdouts = new_stdouts
                time.sleep(0.1)
        except:
            return

    def _get_windows_private_network_interface_index(self, vm: VM):
        route_print = vm.ssh.run_command("route print")
        id = re.search(r"(\d+)\.\.\.([0-9a-fA-F]{2} ){6}\.\.\.\.\.\.Intel\(R\) PRO/1000 MT Desktop Adapter #2",
                       route_print)
        if not id:
            self.log.critical("'route print' returned unknown data:\n%s", route_print)
            sys.exit(1)
        return id.group(1)

    def _get_vm(self, vm_name: str) -> VM | None:
        for vm in self.vms:
            if vm.vm_name == vm_name:
                return vm
        return None

    def _start_router_sniffing(self, attacker_vm: str):
        router = self._get_vm(ROUTER_VM)
        if not router:
            return
        try:
            router.ssh.run_command("pkill mitmdump")
        except:
            pass
        try:
            router.ssh.run_command("sudo pkill tcpdump")
        except:
            pass
        try:
            router.ssh.run_command(f"rm -rf {CVEX_TEMP_FOLDER_LINUX}")
        except:
            pass
        router.ssh.run_command(f"mkdir {CVEX_TEMP_FOLDER_LINUX}")
        router.ssh.run_command("sudo sysctl net.ipv4.ip_forward=1")
        router.tcpdump_runner = router.ssh.run_command(
            f"sudo tcpdump -i eth1 -U -w {TCPDUMP_LOG_PATH}", is_async=True)
        router.tcpdump_thread = threading.Thread(target=self._read_output, args=[router.tcpdump_runner])
        router.tcpdump_thread.start()
        for port in self.ports:
            router.ssh.run_command(
                f"sudo iptables -t nat -I PREROUTING --src 0/0 --dst 0/0 -p tcp --dport {port} -j REDIRECT --to-ports 8080")
        router.mitmdump_runner = router.ssh.run_command(
            f"mitmdump --mode transparent -k --set block_global=false -w {MITMDUMP_LOG_PATH}",
            is_async=True, until="Transparent Proxy listening at")
        router.mitmdump_thread = threading.Thread(target=self._read_output, args=[router.mitmdump_runner])
        router.mitmdump_thread.start()

        vm = self._get_vm(attacker_vm)
        if vm.vm_type == "windows":
            try:
                vm.ssh.run_command((f"powershell \""
                                    f"Get-NetAdapter -Name 'Ethernet 2' | "
                                    f"New-NetIPAddress -IPAddress {vm.ip} -DefaultGateway {router.ip} -PrefixLength 24\""))
            except:
                pass
            vm.ssh.run_command("route DELETE 192.168.56.0")
            id = self._get_windows_private_network_interface_index(vm)
            vm.ssh.run_command(f"route ADD 192.168.56.0 MASK 255.255.255.0 {router.ip} if {id}")
        elif vm.vm_type == "linux":
            try:
                vm.ssh.run_command(f"sudo ip route change 192.168.56.0/24 via {router.ip} dev eth1")
            except:
                pass
            vm.ssh.run_command("sudo systemctl restart ufw")

    def _stop_router_sniffing(self, output_dir: str):
        router = self._get_vm(ROUTER_VM)
        if not router:
            return

        router.ssh.send_ctrl_c(router.tcpdump_runner)
        router.ssh.send_ctrl_c(router.mitmdump_runner)

        self.log.info("Wait for 5 seconds to let tcpdump and mitmdump flush logs on disk...")
        time.sleep(5)

        # router.tcpdump_thread.join()
        # router.mitmdump_thread.join()

        router.ssh.download_file(f"{output_dir}/{TCPDUMP_LOG}", TCPDUMP_LOG_PATH)
        router.ssh.download_file(f"{output_dir}/{MITMDUMP_LOG}", MITMDUMP_LOG_PATH)

    def _start_windows_api_tracing(self, vm: VM):
        with open("data/procmon.pmc", "rb") as f:
            config = procmon_parser.load_configuration(f)
        config["FilterRules"] = [
            procmon_parser.Rule(
                procmon_parser.Column.PROCESS_NAME,
                procmon_parser.RuleRelation.CONTAINS,
                vm.trace,
                procmon_parser.RuleAction.INCLUDE)]
        local_config = tempfile.NamedTemporaryFile()
        with open(local_config.name, "wb") as f:
            procmon_parser.dump_configuration(config, f)
        try:
            vm.ssh.run_command("taskkill /IM Procmon.exe /F")
        except:
            pass
        try:
            vm.ssh.run_command(f"rmdir /S /Q {CVEX_TEMP_FOLDER_WINDOWS}")
        except:
            pass
        vm.ssh.run_command(f"mkdir {CVEX_TEMP_FOLDER_WINDOWS}")

        remote_config_path = f"{CVEX_TEMP_FOLDER_WINDOWS}\\config.pmc"
        vm.ssh.upload_file(local_config.name, f"/{remote_config_path}")
        vm.ssh.run_command(
            f"C:\\Tools\\Procmon.exe /AcceptEula /BackingFile {PROCMON_PML_LOG_PATH} /LoadConfig {remote_config_path} /Quiet",
            is_async=True)

    def _stop_windows_api_tracing(self, vm: VM, output_dir: str):
        vm.ssh.run_command("C:\\Tools\\Procmon.exe /AcceptEula /Terminate")
        vm.ssh.run_command(
            f"C:\Tools\Procmon.exe /AcceptEula /OpenLog {PROCMON_PML_LOG_PATH} /SaveAs {PROCMON_XML_LOG_PATH}")
        vm.ssh.download_file(f"{output_dir}/{vm.vm_name}_{PROCMON_PML_LOG}", f"/{PROCMON_PML_LOG_PATH}")
        vm.ssh.download_file(f"{output_dir}/{vm.vm_name}_{PROCMON_XML_LOG}", f"/{PROCMON_XML_LOG_PATH}")

    def _start_linux_api_tracing(self, vm: VM):
        vm.strace = {}
        try:
            vm.ssh.run_command("sudo pkill strace")
        except:
            pass
        try:
            vm.ssh.run_command(f"rm -rf {CVEX_TEMP_FOLDER_LINUX}")
        except:
            pass
        vm.ssh.run_command(f"mkdir {CVEX_TEMP_FOLDER_LINUX}")

        try:
            procs = vm.ssh.run_command(f"ps -ax | egrep \"{vm.trace}\" | grep -v grep")
        except UnexpectedExit:
            procs = None
        if not procs:
            self.log.critical("VM %s doesn't have processes that match '%s'", vm.vm_name, vm.trace)
            sys.exit(1)
        for pid, proc in re.findall(rf"(\d+).+? ({vm.trace})", procs):
            log = f"{CVEX_TEMP_FOLDER_LINUX}/{vm.vm_name}_strace_{proc}_{pid}.log"
            if log not in vm.strace:
                runner = vm.ssh.run_command(f"sudo strace -p {pid} -o {log} -v", is_async=True, until="attached")
                vm.strace[log] = runner

    def _stop_linux_api_tracing(self, vm: VM, output_dir: str):
        for _, runner in vm.strace.items():
            vm.ssh.send_ctrl_c(runner)
        for log, _ in vm.strace.items():
            out = f"{output_dir}/{log[len(CVEX_TEMP_FOLDER_LINUX) + 1:]}"
            vm.ssh.download_file(out, log)
            self.log.info("strace log was stored to %s", out)

    def _start_api_tracing(self):
        for vm in self.vms:
            if vm.trace:
                if vm.vm_type == "windows":
                    self._start_windows_api_tracing(vm)
                elif vm.vm_type == "linux":
                    self._start_linux_api_tracing(vm)

    def _stop_api_tracing(self, output_dir: str):
        for vm in self.vms:
            if vm.trace:
                if vm.vm_type == "windows":
                    self._stop_windows_api_tracing(vm, output_dir)
                elif vm.vm_type == "linux":
                    self._stop_linux_api_tracing(vm, output_dir)

    def _get_command(self, command_template: str):
        command = command_template
        for vm in self.vms:
            command = command.replace(f"%{vm.vm_name}%", vm.ip)
        return command

    def run(self, attacker_vm: str, command: str, output_dir: str):
        vm = self._get_vm(attacker_vm)
        if not vm:
            self.log.critical("Can't find VM %s", attacker_vm)
            sys.exit(1)

        self._start_router_sniffing(attacker_vm)
        self._start_api_tracing()

        vm.ssh.run_command(self._get_command(command))

        self._stop_router_sniffing(output_dir)
        self._stop_api_tracing(output_dir)
